package main

import "crypto/rand"
import "fmt"
import "strings"
import "strconv"

func check(e error) {
	if e != nil {
		panic(e)
	}
}

func indexIntoBuff (buff []byte, i int) (bool) {
	if (buff[i/8] >> (i%8)) & 1 == 1 {
		return true
	} else {
		return false
	}
}

func deepCompare (a, b []bool) (bool) {
	if len(a) != len(b) {
		return false
	}
	for i, v := range a {
		if v != b[i] {
			return false
		}
	}
	return true
}

var maxdepth int = 128

var prefixes = map[byte]int {
	0b00000000: 1,
	0b00000001: 1,
	0b00000010: 1,
	0b00000011: 1,
	0b00000100: 1,
	0b00000101: 1,
	0b00000110: 1,
	0b00000111: 1,
	0b00001000: 1,
	0b00001001: 1,
	0b00001010: 1,
	0b00001011: 1,
	0b00001100: 1,
	0b00001101: 1,
	0b00001110: 1,
	0b00001111: 1,
	0b00010000: 1,
	0b00010001: 1,
	0b00010010: 1,
	0b00010011: 1,
	0b00010100: 1,
	0b00010101: 1,
	0b00010110: 1,
	0b00010111: 1,
	0b00011000: 1,
	0b00011001: 1,
	0b00011010: 1,
	0b00011011: 1,
	0b00011100: 1,
	0b00011101: 1,
	0b00011110: 1,
	0b00011111: 1,
	0b00100000: 1,
	0b00100001: 1,
	0b00100010: 1,
	0b00100011: 1,
	0b00100100: 1,
	0b00100101: 1,
	0b00100110: 1,
	0b00100111: 1,
	0b00101000: 1,
	0b00101001: 1,
	0b00101010: 1,
	0b00101011: 1,
	0b00101100: 1,
	0b00101101: 1,
	0b00101110: 1,
	0b00101111: 1,
	0b00110000: 1,
	0b00110001: 1,
	0b00110010: 1,
	0b00110011: 1,
	0b00110100: 1,
	0b00110101: 1,
	0b00110110: 1,
	0b00110111: 1,
	0b00111000: 1,
	0b00111001: 1,
	0b00111010: 1,
	0b00111011: 1,
	0b00111100: 1,
	0b00111101: 1,
	0b00111110: 1,
	0b00111111: 1,
	0b01000000: 0,
	0b01000001: 0,
	0b01000010: 0,
	0b01000011: 0,
	0b01000100: 4,
	0b01000101: 0,
	0b01000110: 0,
	0b01000111: 0,
	0b01001000: 3,
	0b01001001: 3,
	0b01001010: 3,
	0b01001011: 3,
	0b01001100: 0,
	0b01001101: 0,
	0b01001110: 0,
	0b01001111: 0,
	0b01010000: 2,
	0b01010001: 2,
	0b01010010: 2,
	0b01010011: 2,
	0b01010100: 2,
	0b01010101: 2,
	0b01010110: 2,
	0b01010111: 2,
	0b01011000: 2,
	0b01011001: 2,
	0b01011010: 2,
	0b01011011: 2,
	0b01011100: 2,
	0b01011101: 2,
	0b01011110: 2,
	0b01011111: 2,
	0b01100000: 0,
	0b01100001: 0,
	0b01100010: 0,
	0b01100011: 0,
	0b01100100: 0,
	0b01100101: 0,
	0b01100110: 4,
	0b01100111: 0,
	0b01101000: 0,
	0b01101001: 0,
	0b01101010: 0,
	0b01101011: 0,
	0b01101100: 3,
	0b01101101: 3,
	0b01101110: 3,
	0b01101111: 3,
	0b01110000: 0,
	0b01110001: 0,
	0b01110010: 0,
	0b01110011: 0,
	0b01110100: 0,
	0b01110101: 0,
	0b01110110: 0,
	0b01110111: 4,
	0b01111000: 0,
	0b01111001: 0,
	0b01111010: 0,
	0b01111011: 0,
	0b01111100: 0,
	0b01111101: 0,
	0b01111110: 0,
	0b01111111: 0,
	0b10000000: 0,
	0b10000001: 0,
	0b10000010: 0,
	0b10000011: 0,
	0b10000100: 0,
	0b10000101: 0,
	0b10000110: 0,
	0b10000111: 0,
	0b10001000: 4,
	0b10001001: 0,
	0b10001010: 0,
	0b10001011: 0,
	0b10001100: 0,
	0b10001101: 0,
	0b10001110: 0,
	0b10001111: 0,
	0b10010000: 3,
	0b10010001: 3,
	0b10010010: 3,
	0b10010011: 3,
	0b10010100: 0,
	0b10010101: 0,
	0b10010110: 0,
	0b10010111: 0,
	0b10011000: 0,
	0b10011001: 4,
	0b10011010: 0,
	0b10011011: 0,
	0b10011100: 0,
	0b10011101: 0,
	0b10011110: 0,
	0b10011111: 0,
	0b10100000: 2,
	0b10100001: 2,
	0b10100010: 2,
	0b10100011: 2,
	0b10100100: 2,
	0b10100101: 2,
	0b10100110: 2,
	0b10100111: 2,
	0b10101000: 2,
	0b10101001: 2,
	0b10101010: 2,
	0b10101011: 2,
	0b10101100: 2,
	0b10101101: 2,
	0b10101110: 2,
	0b10101111: 2,
	0b10110000: 0,
	0b10110001: 0,
	0b10110010: 0,
	0b10110011: 0,
	0b10110100: 3,
	0b10110101: 3,
	0b10110110: 3,
	0b10110111: 3,
	0b10111000: 0,
	0b10111001: 0,
	0b10111010: 0,
	0b10111011: 4,
	0b10111100: 0,
	0b10111101: 0,
	0b10111110: 0,
	0b10111111: 0,
	0b11000000: 1,
	0b11000001: 1,
	0b11000010: 1,
	0b11000011: 1,
	0b11000100: 1,
	0b11000101: 1,
	0b11000110: 1,
	0b11000111: 1,
	0b11001000: 1,
	0b11001001: 1,
	0b11001010: 1,
	0b11001011: 1,
	0b11001100: 1,
	0b11001101: 1,
	0b11001110: 1,
	0b11001111: 1,
	0b11010000: 1,
	0b11010001: 1,
	0b11010010: 1,
	0b11010011: 1,
	0b11010100: 1,
	0b11010101: 1,
	0b11010110: 1,
	0b11010111: 1,
	0b11011000: 1,
	0b11011001: 1,
	0b11011010: 1,
	0b11011011: 1,
	0b11011100: 1,
	0b11011101: 1,
	0b11011110: 1,
	0b11011111: 1,
	0b11100000: 1,
	0b11100001: 1,
	0b11100010: 1,
	0b11100011: 1,
	0b11100100: 1,
	0b11100101: 1,
	0b11100110: 1,
	0b11100111: 1,
	0b11101000: 1,
	0b11101001: 1,
	0b11101010: 1,
	0b11101011: 1,
	0b11101100: 1,
	0b11101101: 1,
	0b11101110: 1,
	0b11101111: 1,
	0b11110000: 1,
	0b11110001: 1,
	0b11110010: 1,
	0b11110011: 1,
	0b11110100: 1,
	0b11110101: 1,
	0b11110110: 1,
	0b11110111: 1,
	0b11111000: 1,
	0b11111001: 1,
	0b11111010: 1,
	0b11111011: 1,
	0b11111100: 1,
	0b11111101: 1,
	0b11111110: 1,
	0b11111111: 1,
}

var randqueue []byte = nil

func dequeueFromRand(s int) ([]byte) {
	if randqueue == nil || len(randqueue) < s {
		buff := make([]byte, 4 * 1024 * 1024)
		_, e := rand.Read(buff)
		check(e)
		randqueue = buff
	}
	out := randqueue[0:s]
	randqueue = randqueue[s:len(randqueue)]
	return out
}

func initSliceFromSource (s int, prefix_check bool) ([]bool, int) {
	buff := dequeueFromRand(s)
	if prefix_check {
		depth, _ := prefixes[buff[0]]
		if depth > 0 {
			return nil, depth
		}
	}
	out := make([]bool, s)
	for i := 0; i < s; i++ {
		out[i] = indexIntoBuff(buff, i)
	}
	return out, -1
}

func main() {
	for {
		results := make([]int, maxdepth)
		for j := 0; j < 100_000; j++ {
			buff, depth := initSliceFromSource(maxdepth, false)
			ret := false
			if depth > 0 {
				results[depth] += 1
			}
			for i := 1; i <= maxdepth/2; i++ {
				ret = deepCompare(buff[0:i], buff[i:2*i])
				if ret {
					results[i] += 1
					break
				}
			}
			if !ret {
				results[0] += 1
			}
		}
		outgo := make([]string, maxdepth)
		for i, v := range results { outgo[i] = strconv.Itoa(v) }
		fmt.Println(strings.Join(outgo, ","))
	}
}
